"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8482],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),p=i,m=u["".concat(c,".").concat(p)]||u[p]||h[p]||r;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1891:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:1},o="Design Decisions",s={unversionedId:"Design/Design Decisions",id:"Design/Design Decisions",title:"Design Decisions",description:"Auticuro can serve as the cornerstone for mission-critical financial applications. To further illustrate this point, the following high-level architecture showcases how Auticuro can be utilized to build a distributed wallet service and highlights its role within the overall system's ecosystem. In order to provide a comprehensive understanding of the architecture, we will also outline the most significant design decisions.",source:"@site/docs/Design/Design Decisions.md",sourceDirName:"Design",slug:"/Design/Design Decisions",permalink:"/Auticuro/docs/Design/Design Decisions",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Design",permalink:"/Auticuro/docs/category/design"},next:{title:"Architecture",permalink:"/Auticuro/docs/Design/Architecture Overview"}},c={},l=[{value:"Architecture of A Distributed Wallet Service",id:"architecture-of-a-distributed-wallet-service",level:2},{value:"Decouple Transaction Layer and Storage Layer",id:"decouple-transaction-layer-and-storage-layer",level:2},{value:"Decouple Flex and Stationary",id:"decouple-flex-and-stationary",level:2},{value:"Decouple Read and Write - CQRS with Event Sourcing",id:"decouple-read-and-write---cqrs-with-event-sourcing",level:2},{value:"Decouple Account Structure and Storage",id:"decouple-account-structure-and-storage",level:2},{value:"Correctness, Dependability, and Performance",id:"correctness-dependability-and-performance",level:2}],d={toc:l},u="wrapper";function h(e){let{components:t,...r}=e;return(0,i.kt)(u,(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"design-decisions"},"Design Decisions"),(0,i.kt)("p",null,"Auticuro can serve as the cornerstone for mission-critical financial applications. To further illustrate this point, the following high-level architecture showcases how Auticuro can be utilized to build a distributed wallet service and highlights its role within the overall system's ecosystem. In order to provide a comprehensive understanding of the architecture, we will also outline the most significant design decisions."),(0,i.kt)("h2",{id:"architecture-of-a-distributed-wallet-service"},"Architecture of A Distributed Wallet Service"),(0,i.kt)("p",null,"As depicted in the following diagram, the distributed wallet service is divided into three layers:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image info",src:n(5980).Z,width:"520",height:"340"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Access Layer")," that translates incoming flexible business requests into underlying stationary\naccount operations,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Transaction Layer"),", a.k.a. Marker, that orchestrates cross-shard money movements with ACID\nguarantees, where ACID refers to the four key properties of a transaction: atomicity, consistency, isolation, and durability."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Storage Layer"),", a.k.a. Auticuro, that supports low-level, high-performance atomic account\noperations within a single shard.")),(0,i.kt)("p",null,"Shards within the same layer do not communicate, while shards from different layers are fully connected. For example, Replicas in Access Layer can talk with any shard from the Transaction Layer or Storage Layer, and shards in the Transaction Layer can talk with any shard from Storage Layer."),(0,i.kt)("h2",{id:"decouple-transaction-layer-and-storage-layer"},"Decouple Transaction Layer and Storage Layer"),(0,i.kt)("p",null,"The most important design decision we made was to decouple the transaction layer and storage layer. The decoupling dramatically decreases the engineering complexity and maintenance overhead while increasing the performance of transaction management and account operations."),(0,i.kt)("p",null,"The transaction layer is computation-intensive, while the storage layer is data-intensive. The transaction layer should be scaled up and down according to the traffic volume, while the storage layer should be scaled up according to the number of accounts. A new shard in the transaction layer can be brought up when encountering traffic spikes and decommissioned as long as it has no ongoing transactions."),(0,i.kt)("p",null,"A shard in the storage layer with a naive single-threaded implementation could easily achieve more than 20,000 account operations per second. In contrast, a carefully designed and implemented shard in the transaction layer can schedule 2,000 transactions per second."),(0,i.kt)("p",null,"According to our prior experience, a monolithic solution is hard to implement and evolve and much slower than the decoupled solution since it needs to handle quite a few complex situations relating to the pending conditional transfer due to the coupling of transaction management and account operation. It is also hard to smoothly scale up and down when encountering traffic spikes since it needs to repartition the accounts while scaling up and repartition again while scaling down, which is quite a burden for maintenance."),(0,i.kt)("h2",{id:"decouple-flex-and-stationary"},"Decouple Flex and Stationary"),(0,i.kt)("p",null,"The wallet service separates the fundamental balance operation APIs from the business-facing APIs, the former is implemented in the storage layer, and the latter is implemented in the access layer. It offers several benefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Independent Scalability: Decoupling the layers allows the scale of each layer independently based on its specific requirements. The fundamental balance operation APIs are stable and should be changed conservatively, while the business-facing APIs need to evolve quickly to adapt to the business requirements."),(0,i.kt)("li",{parentName:"ul"},"Easier to test and debug: Separating the core balance operation APIs from the business-facing APIs makes it simpler to test and debug each layer independently, ensuring a more robust and reliable system.")),(0,i.kt)("h2",{id:"decouple-read-and-write---cqrs-with-event-sourcing"},"Decouple Read and Write - CQRS with Event Sourcing"),(0,i.kt)("p",null,"Command and Query Responsibility Segregation(CQRS) means separating reads and writes into different models, using commands to update data and queries to read data. Commands represent actions to change the state of the system. Usually, we refer to the command as the write operation. We would prefer the use of command and will use it throughout this document. You can think they are the synonym of the write operations. Benefits of CQRS include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Independent scaling. CQRS allows the read and write workloads to scale independently and results in fewer lock contentions."),(0,i.kt)("li",{parentName:"ul"},"Optimized data schemas. The query side can use a schema optimized for queries, while the command side uses a schema optimized for updates."),(0,i.kt)("li",{parentName:"ul"},"Separation of concerns. Segregating the command and query sides can result in models that are more maintainable and flexible. Additionally, the command and query sides could have different optimization and scaling solutions.")),(0,i.kt)("p",null,"Instead of storing just the current state of the data in a domain, in Event Sourcing, an append-only store is used to record the full series of actions taken on that data. The store acts as the golden source, and the records can be used to materialize the domain objects."),(0,i.kt)("p",null,"Marker and Auticuro follow the CQRS pattern with Event Sourcing, each shard of which is separated into the command side and query side, connected by an event store. Only the most critical logic, such as real-time balance check, is processed on the command side. Others are processed on the query side, tailored for query performance."),(0,i.kt)("h2",{id:"decouple-account-structure-and-storage"},"Decouple Account Structure and Storage"),(0,i.kt)("p",null,"The wallet service supports account hierarchy, a tree-like structure where an account can have a bunch of sub-accounts, and the account's balance is the total balance of its sub-accounts."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Money movements are only allowed on the leaf accounts"),(0,i.kt)("li",{parentName:"ul"},"Balance queries of all accounts(leaf account + non-leaf accounts) are supported.")),(0,i.kt)("p",null,"We decouple the two functionalities with CQRS methodology, putting the leaf account storage model on the command(write) side and the account hierarchy models on the query side because these two models are orthogonal. In this way, they can scale or adapt to business change independently."),(0,i.kt)("h2",{id:"correctness-dependability-and-performance"},"Correctness, Dependability, and Performance"),(0,i.kt)("p",null,"The wallet service is implemented in the Rust programming language to achieve correctness and performance. Rust\u2019s rich type system and ownership model guarantee memory safety and thread safety. Rust is blazingly fast and memory efficient: with no runtime or garbage collector, powering performance-critical services."),(0,i.kt)("p",null,"The wallet service employs a single-threaded, lockless critical path to reduce contention, improve throughput, and reduce latency. This choice dramatically reduces the engineering complexity as error-prone multi-threaded code is discarded without hurting the performance."),(0,i.kt)("p",null,"The command side of Marker and Auticuro is built on top of the ",(0,i.kt)("a",{parentName:"p",href:"https://raft.github.io/"},"Raft algorithm"),", leveraging Raft to achieve strong consistency and high availability. Raft is a consensus algorithm, which is a protocol used in distributed systems to achieve agreement among multiple nodes on a specific value or state, even in the presence of failures. Raft achieves consensus via an elected leader. A server in a raft cluster is either a leader or a follower and can be a candidate in the precise case of an election (leader unavailable). The leader is responsible for log replication to the followers."))}h.isMDXComponent=!0},5980:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/High_level_architecture-3817d0d4cf553f9ff60f7bc9bef43eb6.svg"}}]);
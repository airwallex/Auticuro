---
sidebar_position: 3
---

# Command Side
Auticuro leverages a CQRS with Event Sourcing architecture, in which the command side is
write-intensive and serves as the source of truth for the system. To ensure high throughput and 
safety, Auticuro incorporates a Raft-based cluster that uses an LMAX-like architecture. The 
following sections will illustrate the intricacies of Auticuro command-side's implementation.

![image info](@site/static/img/design/firm-wallet-c-side.svg)

The above figure shows how a TransferRequest is handled inside the leader of one Auticuro shard, 
supporting real-time balance checks in the critical path:

The TransferRequest is persisted into the raft log unconditionally, even if it is a duplicated one.
In real life, one raft log entry may consist of a batch of transfer requests to amortize the time
cost of permanently writing the data to disk, done by the system call fsync of Linux/Unix.

The event log stores the balance change event generated by the transfer request. Each event is
assigned a consecutive integer starting from 1, used by downstream systems to verify the integrity
of the event stream. A duplicated transfer request in the raft log will be detected by DedupId Store
and discarded, leaving the BalanceMap unchanged and no event generated.

**Thread 1: The Foreground gRPC Thread**
* **Step 1**. The gRPC thread accepts a TransferRequest, appends it to the raft log, waits for that 
request to be committed, and receives the corresponding raft log_index (This implies that the log 
entry has been persisted on the majority nodes and is ready to be applied).
* **Step 2**. The gRPC thread registers the TransferRequest into the MessageBroker with that 
log_index and waits for the TransferResponse from the MessageBroker and replies that response to the client.

**Thread 2: Single-Threaded Log Consumer**
* **Step 1**. The LogConsumer polls that committed log entry from the raft log and deserializes the
log entry to the TransferRequest.
* **Step 2**. The LogConsumer sends the TransferRequest to the WalletStateMachine via the Single 
Producer Single Consumer (SPSC) channel.

**Thread 3: Single-Threaded Lockless Critical Path**
* **Step 1**. The WalletStateMachine receives the TransferRequest from the SPSC channel, 
de-duplicates via DedupId Store, updates the BalanceMap, generates the TransferResponse and
BalanceChangeEvent, and persists both BalanceChangeEvent and dedupId into RocksDB.
* **Step 2**. The WalletStateMachine registers the TransferResponse into the MessageBroker with that log_index.

**Thread 4: Single-Threaded Message Broker**
* **Match**. The MessageBroker is an infinite loop matching the TransferRequest from the gRPC thread 
and the TransferResponse from the WalletStateMachine via the log_index.
